/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Decoder for audio files in various formats (WAV, MP3, FLAC, OGG, etc.) */
export declare class AudioDecoder {
  /** Create a decoder from a file path */
  constructor(filePath: string)
  /** Create a decoder from raw audio data */
  static fromData(data: Array<number>): AudioDecoder
  /** Get sample rate of decoded audio */
  getSampleRate(): number
  /** Get number of channels (1=mono, 2=stereo, etc.) */
  getChannels(): number
  /** Get duration in seconds */
  getDuration(): number
  /** Reset decoder to beginning */
  reset(): void
  /** Decode all audio samples into a vector */
  decodeToSamples(): Array<number>
  /** Get a slice of decoded samples (limited by duration to prevent memory issues) */
  decodeSlice(startSeconds: number, endSeconds: number): Array<number>
  /** Check if this is a stereo file */
  isStereo(): boolean
  /** Check if this is a mono file */
  isMono(): boolean
}

/** Thread-safe audio player with rodio backend */
export declare class AudioPlayer {
  constructor()
  getDevices(): Array<AudioDeviceInfo>
  loadFile(filePath: string): void
  loadBuffer(audioData: Array<number>): void
  loadBase64(base64Data: string): void
  play(): void
  pause(): void
  stop(): void
  setVolume(volume: number): void
  getVolume(): number
  isPlaying(): boolean
  getState(): PlaybackState
  getDuration(): number
  getCurrentTime(): number
  getCurrentFile(): string | null
  seekTo(position: number): void
}

export declare class AudioRecorder {
  constructor()
  setOnData(callback: ((err: Error | null, arg: Array<number>) => any)): void
  setRingBufferSize(sizeSamples: number): void
  start(deviceId?: string | undefined | null): void
  stop(): void
  isRecording(): boolean
  getBuffer(): SamplesBuffer
  getRingBufferSamples(): Array<number>
  clear(): void
  getConfig(): RecorderConfig
  getLevels(): AudioLevels
}

/** A queue for managing multiple audio sources that play in sequence */
export declare class AudioSourceQueue {
  constructor()
  /** Add an audio source from a file */
  addSource(filePath: string, title?: string | undefined | null): string
  /** Add an audio source from a buffer */
  addBuffer(buffer: Array<number>, title?: string | undefined | null): string
  /** Remove a source by its ID */
  removeSource(sourceId: string): void
  /** Get a specific source by its ID */
  getSource(sourceId: string): AudioQueueItem
  getSources(): Array<AudioQueueItem>
  getLength(): number
  getCurrentIndex(): number
  setCurrentIndex(index: number): void
  clear(): void
  isPlaying(): boolean
  setPlaying(playing: boolean): void
}

/** Audio stream for real-time playback */
export declare class AudioStream {
  constructor()
  /** Open and initialize the audio stream */
  open(): void
  /** Play an audio file */
  playFile(filePath: string): void
  /** Play raw audio data from buffer */
  playBuffer(buffer: SamplesBuffer): void
  /** Play base64 encoded audio data */
  playBase64(base64Data: string): void
  /** Get the current playback state */
  getState(): PlayError
  /** Check if audio is currently playing */
  isPlaying(): boolean
  /** Pause the stream */
  pause(): void
  /** Resume the stream */
  resume(): void
  /** Stop the stream */
  stop(): void
  /** Set the master volume (0.0 to 1.0) */
  setVolume(volume: number): void
  /** Get the current volume */
  getVolume(): number
  /** Get supported stream configurations */
  static getSupportedConfigs(): Array<SupportedStreamConfig>
}

/** Stream builder for creating audio streams with specific configurations */
export declare class AudioStreamBuilder {
  constructor()
  setSampleRate(rate: number): void
  setChannels(channels: number): void
  setBufferSize(size: number): void
  build(): AudioStream
}

/** Blue noise generator - high frequency emphasis */
export declare class BlueNoise {
  constructor(durationMs: number, sampleRate: number, channels: number)
  getSamples(): Array<number>
  getNext(): number | null
  reset(): void
}

/** Brownian noise (random walk) - low frequency emphasis */
export declare class BrownianNoise {
  constructor(durationMs: number, sampleRate: number, channels: number)
  getSamples(): Array<number>
  getNext(): number | null
  reset(): void
}

/** Channel count converter - handles converting between mono, stereo, and multi-channel audio */
export declare class ChannelCountConverter {
  constructor(sourceChannels: number, targetChannels: number)
  /** Convert audio samples from source channel count to target channel count */
  convert(samples: Array<number>): Array<number>
  sourceChannels(): number
  targetChannels(): number
}

/** Decoder builder for configuring decoder behavior */
export declare class DecoderBuilder {
  constructor()
  setLoopEnabled(enabled: boolean): void
  setLoopCount(count: number): void
  setSampleRate(rate: number): void
  setChannels(channels: number): void
  buildFromFile(filePath: string): AudioDecoder
  buildFromData(data: Array<number>): AudioDecoder
  buildLooped(filePath: string): LoopedDecoder
}

/** Decoder builder settings */
export declare class DecoderBuilderSettings {
  enableLooping: boolean
  loopCount: number
  sampleRate?: number
  channels?: number
}

/** Looped decoder - decodes audio and repeats it indefinitely */
export declare class LoopedDecoder {
  /** Create a new looped decoder */
  constructor(decoder: AudioDecoder, loopCount?: number | undefined | null)
  /** Get the loop count (0 = infinite) */
  getLoopCount(): number
  /** Set the loop count (use u32::MAX for infinite) */
  setLoopCount(count: number): void
  /** Decode with loops applied */
  decodeLooped(): Array<number>
  /** Get reference to inner decoder */
  getDecoder(): AudioDecoder
}

/** A mixer that combines multiple audio sources into a single output stream */
export declare class Mixer {
  /** Create a new mixer with default settings (44100 Hz, stereo, max 16 sources) */
  constructor()
  /** Create a mixer with custom configuration */
  static withConfig(sampleRate: number, channels: number, maxSources: number): Mixer
  /** Add an audio source to the mixer */
  addSource(source: MixerSource): void
  /** Remove a source by its ID */
  removeSource(sourceId: string): void
  /** Get all current sources */
  getSources(): Array<MixerSource>
  /** Get the number of sources */
  getSourceCount(): number
  /** Clear all sources */
  clear(): void
  /**
   * Mix all sources at a specific time point (synchronous operation)
   * Returns a buffer of mixed samples
   */
  sampleAt(timeMs: number): Array<number>
  /** Start mixing multiple sources in real-time (simulated) */
  startMixing(): void
  /** Stop all mixing */
  stopMixing(): void
  /** Get the sample rate of the mixer */
  getSampleRate(): number
  /** Get the channel count of the mixer */
  getChannels(): number
  /** Set the master volume (0.0 to 1.0) */
  setMasterVolume(volume: number): void
  /** Get the master volume */
  getMasterVolume(): number
}

/** A source that can be added to a mixer */
export declare class MixerSource {
  constructor(id: string, samples: Array<number>, sampleRate: number, channels: number)
  /** Get source ID */
  getId(): string
  /** Get audio samples */
  getSamples(): Array<number>
  /** Get samples at a specific time (simplified to return relative audio) */
  getSamplesAt(timeMs: number): Array<number>
  /** Get sample rate */
  getSampleRate(): number
  /** Get channels */
  getChannels(): number
  /** Set volume (0.0 to 1.0) */
  setVolume(volume: number): void
  /** Get volume */
  getVolume(): number
  /** Set pan (-1.0 left, 0.0 center, 1.0 right) */
  setPan(pan: number): void
  /** Get pan */
  getPan(): number
  /** Enable or disable source */
  setEnabled(enabled: boolean): void
  /** Check if source is enabled */
  isEnabled(): boolean
  /** Get duration in milliseconds */
  durationMs(): number
}

/** Pink noise generator - equal power per octave */
export declare class PinkNoise {
  constructor(durationMs: number, sampleRate: number, channels: number)
  getSamples(): Array<number>
  getNext(): number | null
  reset(): void
}

/** Sample rate converter - handles converting between different sample rates (e.g., 44100 to 48000) */
export declare class SampleRateConverter {
  constructor(sourceRate: number, targetRate: number)
  /** Convert audio samples from source rate to target rate using linear interpolation */
  convert(samples: Array<number>): Array<number>
  sourceRate(): number
  targetRate(): number
}

/** A buffer containing audio samples */
export declare class SamplesBuffer {
  /** Create a new samples buffer */
  constructor(channels: number, sampleRate: number, samples: Array<number>)
  /** Get the number of channels in this buffer (1=mono, 2=stereo) */
  getChannels(): number
  /** Get the sample rate of this buffer */
  getSampleRate(): number
  /** Get the number of samples in this buffer */
  getLen(): number
  /** Get the duration of this buffer in seconds */
  getDuration(): number
  /** Get a copy of the samples in this buffer */
  getSamples(): Array<number>
  /** Create a buffer from raw bytes (16-bit little-endian samples) */
  static fromBytes(bytes: Array<number>, channels: number, sampleRate: number): SamplesBuffer
  /** Play this buffer with the given sink */
  play(): void
}

/** Sample type converter - handles converting between different bit depths (8, 16, 24, 32 bit) */
export declare class SampleTypeConverter {
  constructor(sourceBits: number, targetBits: number)
  /** Convert between different sample bit depths */
  convert(samples: Array<number>): Array<number>
  sourceBits(): number
  targetBits(): number
}

export declare class SourcesQueueInput {
  constructor()
  pushFile(filePath: string): string
  pushBuffer(buffer: Array<number>): string
  setTitle(sourceId: string, title: string): void
}

/** Queue output interface - for consuming sources from a queue */
export declare class SourcesQueueOutput {
  constructor()
  peek(): AudioQueueItem
  pop(): AudioQueueItem
  hasNext(): boolean
  getRemaining(): number
}

/** Static buffer that owns its audio data */
export declare class StaticSamplesBuffer {
  constructor(channels: number, sampleRate: number, samples: Array<number>)
  getInner(): SamplesBuffer
}

/** Velvet noise - sparse, crackly noise */
export declare class VelvetNoise {
  constructor(durationMs: number, sampleRate: number, channels: number)
  getSamples(): Array<number>
  getNext(): number | null
  reset(): void
}

/** Violet noise - very high frequency emphasis */
export declare class VioletNoise {
  constructor(durationMs: number, sampleRate: number, channels: number)
  getSamples(): Array<number>
  getNext(): number | null
  reset(): void
}

/** White Gaussian noise */
export declare class WhiteGaussianNoise {
  constructor(durationMs: number, sampleRate: number, channels: number, stdDev?: number | undefined | null)
  getSamples(): Array<number>
  getNext(): number | null
  reset(): void
}

/** White Triangular noise */
export declare class WhiteTriangularNoise {
  constructor(durationMs: number, sampleRate: number, channels: number)
  getSamples(): Array<number>
  getNext(): number | null
  reset(): void
}

/** White Uniform noise (standard random noise) */
export declare class WhiteUniformNoise {
  constructor(durationMs: number, sampleRate: number, channels: number)
  getSamples(): Array<number>
  getNext(): number | null
  reset(): void
}

/** Audio device information structure */
export interface AudioDeviceInfo {
  id: string
  name: string
  host: string
  isDefault: boolean
}

export interface AudioHostInfo {
  id: string
  name: string
}

export interface AudioLevels {
  peak: number
  rms: number
}

export interface AudioMetadata {
  duration: number
  title?: string
  artist?: string
  album?: string
}

export interface AudioPlayerConfig {
  volume?: number
  autoPlay?: boolean
  debug?: boolean
}

export interface AudioQueueItem {
  sourceId: string
  filePath?: string
  buffer?: Array<number>
  title?: string
}

/** Parameters for channel count conversion */
export interface ChannelCountConversion {
  sourceChannels: number
  targetChannels: number
}

export declare function createAudioPlayer(config?: AudioPlayerConfig | undefined | null): AudioPlayer

/**
 * Converts a value from decibels to linear gain (multiplier).
 *
 * # Example
 * ```
 * // -6dB is approximately 0.5
 * assert!(db_to_linear(-6.0) < 0.51 && db_to_linear(-6.0) > 0.49);
 * // 0dB is 1.0
 * assert_eq!(db_to_linear(0.0), 1.0);
 * ```
 *
 * # Arguments
 * * `db` - Value in decibels
 *
 * # Returns
 * Linear gain multiplier (0.0 to infinity)
 */
export declare function dbToLinear(db: number): number

/** Decoder error types (for audio decoding operations) */
export declare const enum DecoderError {
  InvalidFormat = 'InvalidFormat',
  CorruptedData = 'CorruptedData',
  UnsupportedCodec = 'UnsupportedCodec',
  IoError = 'IoError'
}

/** Error types for device operations */
export declare const enum DevicesError {
  NoDevicesFound = 'NoDevicesFound',
  PermissionDenied = 'PermissionDenied',
  InvalidDevice = 'InvalidDevice',
  NotInitialized = 'NotInitialized'
}

export declare function getAudioInfo(): string

export declare function getAudioMetadata(filePath: string): AudioMetadata

export declare function getAvailableHosts(): Array<AudioHostInfo>

export declare function getInputDevices(): Array<AudioDeviceInfo>

export declare function getInputDevicesByHost(hostName: string): Array<AudioDeviceInfo>

export declare function getSupportedFormats(): Array<string>

export declare function initializeAudio(): string

/** Get current debug logging state */
export declare function isDebugEnabled(): boolean

export declare function isFormatSupported(format: string): boolean

/**
 * Converts a linear gain multiplier to decibels.
 *
 * # Example
 * ```
 * // 0.5 is approximately -6dB
 * assert!((linear_to_db(0.5) + 6.0).abs() < 0.1);
 * // 1.0 is 0dB
 * assert_eq!(linear_to_db(1.0), 0.0);
 * ```
 *
 * # Arguments
 * * `linear` - Linear gain multiplier
 *
 * # Returns
 * Value in decibels
 */
export declare function linearToDb(linear: number): number

/** Create a new mixer instance */
export declare function mixer(maxSources?: number | undefined | null): Mixer

/** Create pink noise (with 1/f frequency spectrum) */
export declare function pink(durationMs: number, sampleRate: number, channels: number): PinkNoise

/** Create and open a stream for audio playback */
export declare function play(filePath: string): AudioStream

/**
 * Audio player state enumeration
 * Audio player state enumeration
 */
export declare const enum PlaybackState {
  Stopped = 'Stopped',
  Loaded = 'Loaded',
  Playing = 'Playing',
  Paused = 'Paused'
}

/** Play error for stream operations */
export declare const enum PlayError {
  AlreadyPlaying = 'AlreadyPlaying',
  NotLoaded = 'NotLoaded',
  SystemError = 'SystemError'
}

/** Creates a new audio source queue */
export declare function queue(): AudioSourceQueue

export declare function quickPlay(filePath: string, config?: AudioPlayerConfig | undefined | null): AudioPlayer

export interface RecorderConfig {
  sampleRate: number
  channels: number
  sampleFormat: string
}

/** Parameters for sample rate conversion */
export interface SampleRateConversion {
  sourceRate: number
  targetRate: number
}

/** Parameters for sample type conversion */
export interface SampleTypeConversion {
  sourceBits: number
  targetBits: number
}

/** Seek error types */
export declare const enum SeekError {
  InvalidPosition = 'InvalidPosition',
  NotSeekable = 'NotSeekable',
  OutOfBounds = 'OutOfBounds'
}

/** Enable or disable debug logging (defaults to false) */
export declare function setDebug(enabled: boolean): void

/** Audio source function types (for generator sources) */
export declare const enum SourceFunction {
  Sine = 'Sine',
  Square = 'Square',
  Sawtooth = 'Sawtooth',
  Triangle = 'Triangle',
  WhiteNoise = 'WhiteNoise',
  PinkNoise = 'PinkNoise',
  BrownNoise = 'BrownNoise'
}

/** Error types for stream operations */
export declare const enum StreamError {
  NotPlaying = 'NotPlaying',
  EndOfFile = 'EndOfFile',
  InvalidData = 'InvalidData',
  UnsupportedFormat = 'UnsupportedFormat'
}

/** Stream output configuration */
export interface StreamOutputConfig {
  sampleRate?: SampleRate
  channels?: ChannelCount
  bufferSize?: number
}

/** Stream play error */
export declare const enum StreamPlayError {
  AlreadyPlaying = 'AlreadyPlaying',
  NotReady = 'NotReady',
  SystemError = 'SystemError'
}

/** Get supported output configurations for the audio system */
export declare function supportedOutputConfigs(): Array<SupportedStreamConfig>

/** Supported stream configuration */
export interface SupportedStreamConfig {
  sampleRate: SampleRate
  channelCount: ChannelCount
  sampleWidth: number
}

export declare function testTone(frequency: number, durationMs: number): void

/** Create white noise (neutral frequency spectrum) */
export declare function white(durationMs: number, sampleRate: number, channels: number): WhiteUniformNoise
