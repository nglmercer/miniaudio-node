// Copyright (c) The miniaudio_node Contributors
// SPDX-License-Identifier: MIT

use napi_derive::napi;
use std::sync::{Arc, Mutex};

/// Pink noise source - 1/f frequency spectrum
#[napi]
pub struct Pink {
    samples: Arc<Mutex<Vec<i16>>>,
    position: Arc<Mutex<usize>>,
}

#[napi]
impl Pink {
    /// Create a new pink noise generator
    #[napi(constructor)]
    pub fn new(duration_ms: u32, sample_rate: u32, channels: u16) -> Self {
        let total_samples =
            ((duration_ms as f64 * sample_rate as f64 / 1000.0) as usize) * channels as usize;
        let mut samples = Vec::with_capacity(total_samples);

        use rand::Rng;
        let mut rng = rand::thread_rng();

        // Paul Kellet's pink noise approximation
        let mut b0: f64 = 0.0;
        let mut b1: f64 = 0.0;
        let mut b2: f64 = 0.0;
        let mut b3: f64 = 0.0;
        let mut b4: f64 = 0.0;
        let mut b5: f64 = 0.0;
        let mut b6: f64 = 0.0;

        for _ in 0..total_samples {
            let white = rng.gen::<f64>() * 2.0 - 1.0;

            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;

            let pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            b6 = white * 0.115926;

            // Scale to i16 range and clamp
            let sample = (pink * 16384.0).clamp(-32768.0, 32767.0) as i16;
            samples.push(sample);
        }

        Self {
            samples: Arc::new(Mutex::new(samples)),
            position: Arc::new(Mutex::new(0)),
        }
    }

    /// Get all samples generated by the pink noise
    #[napi]
    pub fn get_samples(&self) -> Vec<i16> {
        self.samples.lock().unwrap().clone()
    }

    /// Get the next sample, looping back to the start if at the end
    #[napi]
    pub fn get_next(&self) -> i16 {
        let mut pos = self.position.lock().unwrap();
        let samples = self.samples.lock().unwrap();

        if *pos >= samples.len() {
            *pos = 0; // Loop
        }

        let sample = samples[*pos];
        *pos += 1;
        sample
    }

    /// Reset playback position to the beginning
    #[napi]
    pub fn reset(&self) {
        *self.position.lock().unwrap() = 0;
    }
}

/// Generate pink noise as a Vec of samples
#[napi]
pub fn pink(duration_ms: u32, sample_rate: u32, channels: u16) -> Vec<i16> {
    Pink::new(duration_ms, sample_rate, channels).get_samples()
}
